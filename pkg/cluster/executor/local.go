package executor

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/zilliztech/miup/pkg/cluster/spec"
	"gopkg.in/yaml.v3"
)

// LocalExecutor executes instance operations using Docker Compose (standalone mode only)
type LocalExecutor struct {
	workDir       string
	instanceName  string
	spec          *spec.Specification
	milvusVersion string
	projectName   string
}

// NewLocalExecutor creates a new local executor
func NewLocalExecutor(workDir, instanceName string, s *spec.Specification, milvusVersion string) (*LocalExecutor, error) {
	return &LocalExecutor{
		workDir:       workDir,
		instanceName:  instanceName,
		spec:          s,
		milvusVersion: milvusVersion,
		projectName:   fmt.Sprintf("miup-%s", instanceName),
	}, nil
}

// Deploy deploys the instance
func (e *LocalExecutor) Deploy(ctx context.Context) error {
	// Generate docker-compose.yaml
	composeContent, err := e.generateComposeFile()
	if err != nil {
		return fmt.Errorf("failed to generate compose file: %w", err)
	}

	composePath := e.composePath()
	if err := os.WriteFile(composePath, []byte(composeContent), 0644); err != nil {
		return fmt.Errorf("failed to write compose file: %w", err)
	}

	// Generate prometheus config if monitoring is enabled
	if e.spec.HasMonitoring() {
		prometheusConfig := e.generatePrometheusConfig()
		prometheusPath := filepath.Join(e.workDir, "prometheus.yml")
		if err := os.WriteFile(prometheusPath, []byte(prometheusConfig), 0644); err != nil {
			return fmt.Errorf("failed to write prometheus config: %w", err)
		}
	}

	// Setup TLS if enabled
	if e.spec.HasTLS() {
		if err := e.setupTLS(); err != nil {
			return fmt.Errorf("failed to setup TLS: %w", err)
		}
	}

	// Start containers
	return e.run(ctx, "up", "-d", "--remove-orphans", "--wait")
}

// Start starts the instance
func (e *LocalExecutor) Start(ctx context.Context) error {
	return e.run(ctx, "start")
}

// Stop stops the instance
func (e *LocalExecutor) Stop(ctx context.Context) error {
	return e.run(ctx, "stop")
}

// Destroy destroys the instance
func (e *LocalExecutor) Destroy(ctx context.Context) error {
	return e.run(ctx, "down", "-v", "--remove-orphans")
}

// Status returns the instance status
func (e *LocalExecutor) Status(ctx context.Context) (string, error) {
	return e.runOutput(ctx, "ps", "--format", "table")
}

// IsRunning checks if the instance is running
func (e *LocalExecutor) IsRunning(ctx context.Context) (bool, error) {
	output, err := e.runOutput(ctx, "ps", "-q")
	if err != nil {
		return false, nil
	}
	return strings.TrimSpace(output) != "", nil
}

// Logs retrieves logs from a service
func (e *LocalExecutor) Logs(ctx context.Context, service string, tail int) (string, error) {
	args := []string{"logs", "--tail", fmt.Sprintf("%d", tail)}
	if service != "" {
		args = append(args, service)
	}
	return e.runOutput(ctx, args...)
}

func (e *LocalExecutor) composePath() string {
	return filepath.Join(e.workDir, "docker-compose.yaml")
}

func (e *LocalExecutor) run(ctx context.Context, args ...string) error {
	cmd := e.buildCommand(ctx, args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

func (e *LocalExecutor) runOutput(ctx context.Context, args ...string) (string, error) {
	cmd := e.buildCommand(ctx, args...)
	output, err := cmd.CombinedOutput()
	return string(output), err
}

func (e *LocalExecutor) buildCommand(ctx context.Context, args ...string) *exec.Cmd {
	baseArgs := []string{"compose", "-f", e.composePath(), "-p", e.projectName}
	baseArgs = append(baseArgs, args...)
	cmd := exec.CommandContext(ctx, "docker", baseArgs...)
	cmd.Dir = e.workDir
	return cmd
}

// ComposeData contains data for docker-compose template
type ComposeData struct {
	InstanceName  string
	MilvusVersion string
	EtcdVersion   string
	MinioVersion  string
	Spec          *spec.Specification
	HasMonitoring bool
	HasTLS        bool
}

const standaloneComposeTemplate = `# MiUp Instance - {{.InstanceName}}
# Mode: standalone
# Generated by miup, do not edit manually

services:
  etcd:
    container_name: {{.InstanceName}}-etcd
    image: quay.io/coreos/etcd:v{{.EtcdVersion}}
    environment:
      - ETCD_AUTO_COMPACTION_MODE=revision
      - ETCD_AUTO_COMPACTION_RETENTION=1000
      - ETCD_QUOTA_BACKEND_BYTES=4294967296
      - ETCD_SNAPSHOT_COUNT=50000
    volumes:
      - etcd_data:/etcd
    command: etcd -advertise-client-urls=http://127.0.0.1:{{(index .Spec.EtcdServers 0).ClientPort}} -listen-client-urls http://0.0.0.0:{{(index .Spec.EtcdServers 0).ClientPort}} --data-dir /etcd
    healthcheck:
      test: ["CMD", "etcdctl", "endpoint", "health"]
      interval: 30s
      timeout: 20s
      retries: 3
    ports:
      - "{{(index .Spec.EtcdServers 0).ClientPort}}:{{(index .Spec.EtcdServers 0).ClientPort}}"
    networks:
      - milvus

  minio:
    container_name: {{.InstanceName}}-minio
    image: minio/minio:{{.MinioVersion}}
    environment:
      MINIO_ACCESS_KEY: {{(index .Spec.MinioServers 0).AccessKey}}
      MINIO_SECRET_KEY: {{(index .Spec.MinioServers 0).SecretKey}}
    ports:
      - "{{(index .Spec.MinioServers 0).Port}}:9000"
      - "{{(index .Spec.MinioServers 0).ConsolePort}}:9001"
    volumes:
      - minio_data:/minio_data
    command: minio server /minio_data --console-address ":9001"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3
    networks:
      - milvus

  standalone:
    container_name: {{.InstanceName}}-standalone
    image: milvusdb/milvus:{{.MilvusVersion}}
    command: ["milvus", "run", "standalone"]
    security_opt:
      - seccomp:unconfined
    environment:
      ETCD_ENDPOINTS: etcd:{{(index .Spec.EtcdServers 0).ClientPort}}
      MINIO_ADDRESS: minio:9000
      MINIO_ACCESS_KEY_ID: {{(index .Spec.MinioServers 0).AccessKey}}
      MINIO_SECRET_ACCESS_KEY: {{(index .Spec.MinioServers 0).SecretKey}}
    volumes:
      - milvus_data:/var/lib/milvus
{{- if .HasTLS}}
      - ./tls:/milvus/tls:ro
      - ./user.yaml:/milvus/configs/user.yaml:ro
{{- end}}
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9091/healthz"]
      interval: 30s
      start_period: 90s
      timeout: 20s
      retries: 3
    ports:
      - "{{(index .Spec.MilvusServers 0).Port}}:19530"
      - "9091:9091"
{{- if .HasTLS}}
      - "9080:9080"
{{- end}}
    depends_on:
      etcd:
        condition: service_healthy
      minio:
        condition: service_healthy
    networks:
      - milvus
{{if .HasMonitoring}}
  prometheus:
    container_name: {{.InstanceName}}-prometheus
    image: prom/prometheus:latest
    ports:
      - "{{(index .Spec.MonitorServers 0).PrometheusPort}}:9090"
    volumes:
      - prometheus_data:/prometheus
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.enable-lifecycle'
    networks:
      - milvus
{{end}}
{{if gt (len .Spec.GrafanaServers) 0}}
  grafana:
    container_name: {{.InstanceName}}-grafana
    image: grafana/grafana:latest
    ports:
      - "{{(index .Spec.GrafanaServers 0).Port}}:3000"
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD={{(index .Spec.GrafanaServers 0).AdminPassword}}
      - GF_USERS_ALLOW_SIGN_UP=false
    volumes:
      - grafana_data:/var/lib/grafana
    depends_on:
      - prometheus
    networks:
      - milvus
{{end}}
networks:
  milvus:
    driver: bridge

volumes:
  etcd_data:
  minio_data:
  milvus_data:
{{- if .HasMonitoring}}
  prometheus_data:
{{- end}}
{{- if gt (len .Spec.GrafanaServers) 0}}
  grafana_data:
{{- end}}
`

func (e *LocalExecutor) generateComposeFile() (string, error) {
	data := ComposeData{
		InstanceName:  e.instanceName,
		MilvusVersion: e.milvusVersion,
		EtcdVersion:   "3.5.18",
		MinioVersion:  "RELEASE.2023-03-20T20-16-18Z",
		Spec:          e.spec,
		HasMonitoring: e.spec.HasMonitoring(),
		HasTLS:        e.spec.HasTLS(),
	}

	tmpl, err := template.New("compose").Parse(standaloneComposeTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.String(), nil
}

func (e *LocalExecutor) generatePrometheusConfig() string {
	return fmt.Sprintf(`global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: 'milvus'
    static_configs:
      - targets: ['standalone:9091']
        labels:
          instance: '%s'
`, e.instanceName)
}

// setupTLS sets up TLS configuration for Milvus
func (e *LocalExecutor) setupTLS() error {
	tlsConfig := e.spec.Global.TLS

	// Create tls directory
	tlsDir := filepath.Join(e.workDir, "tls")
	if err := os.MkdirAll(tlsDir, 0755); err != nil {
		return fmt.Errorf("failed to create tls directory: %w", err)
	}

	// Copy certificate files
	certFiles := map[string]string{
		tlsConfig.CertFile: "server.pem",
		tlsConfig.KeyFile:  "server.key",
	}
	if tlsConfig.CAFile != "" {
		certFiles[tlsConfig.CAFile] = "ca.pem"
	}

	for src, dst := range certFiles {
		if src == "" {
			continue
		}
		srcData, err := os.ReadFile(src)
		if err != nil {
			return fmt.Errorf("failed to read certificate file %s: %w", src, err)
		}
		dstPath := filepath.Join(tlsDir, dst)
		if err := os.WriteFile(dstPath, srcData, 0644); err != nil {
			return fmt.Errorf("failed to write certificate file %s: %w", dstPath, err)
		}
	}

	// Generate user.yaml with TLS configuration (uses user.yaml to only override TLS settings, keeping defaults)
	milvusConfig := e.generateMilvusConfig()
	userConfigPath := filepath.Join(e.workDir, "user.yaml")
	if err := os.WriteFile(userConfigPath, []byte(milvusConfig), 0644); err != nil {
		return fmt.Errorf("failed to write user.yaml: %w", err)
	}

	return nil
}

// generateMilvusConfig generates Milvus configuration with TLS settings
func (e *LocalExecutor) generateMilvusConfig() string {
	tlsConfig := e.spec.Global.TLS
	tlsMode := e.spec.GetTLSMode()

	config := fmt.Sprintf(`# Milvus Configuration - Generated by miup
# TLS Mode: %d (%s)

tls:
  serverPemPath: /milvus/tls/server.pem
  serverKeyPath: /milvus/tls/server.key
`, tlsMode, tlsModeDescription(tlsMode))

	// Add CA file path if provided
	if tlsConfig.CAFile != "" {
		config += "  caPemPath: /milvus/tls/ca.pem\n"
	}

	// Add TLS mode and proxy HTTP port configuration
	// When TLS is enabled, HTTP and gRPC must use different ports
	config += fmt.Sprintf(`
common:
  security:
    tlsMode: %d

proxy:
  http:
    enabled: true
    port: 9080
`, tlsMode)

	// Add internal TLS if enabled
	if tlsConfig.InternalEnabled {
		config += `    internaltlsEnabled: true

internaltls:
  serverPemPath: /milvus/tls/server.pem
  serverKeyPath: /milvus/tls/server.key
  caPemPath: /milvus/tls/ca.pem
`
	}

	return config
}

func tlsModeDescription(mode int) string {
	switch mode {
	case 1:
		return "one-way TLS"
	case 2:
		return "two-way TLS (mutual TLS)"
	default:
		return "unknown"
	}
}

// Scale is not supported for local deployments (standalone mode only)
func (e *LocalExecutor) Scale(ctx context.Context, component string, opts ScaleOptions) error {
	return fmt.Errorf("scaling is not supported for local deployments. Local mode only supports standalone Milvus. Use Kubernetes deployment for scaling")
}

// GetReplicas returns the current replica count for local deployment
func (e *LocalExecutor) GetReplicas(ctx context.Context) (map[string]int, error) {
	// Local deployment is always standalone with 1 replica
	running, err := e.IsRunning(ctx)
	if err != nil {
		return nil, err
	}

	replicas := make(map[string]int)
	if running {
		replicas["standalone"] = 1
	} else {
		replicas["standalone"] = 0
	}
	return replicas, nil
}

// Upgrade upgrades the local Milvus deployment to the specified version
func (e *LocalExecutor) Upgrade(ctx context.Context, version string) error {
	// Normalize version format
	if !strings.HasPrefix(version, "v") {
		version = "v" + version
	}

	// Check if already at the target version
	if e.milvusVersion == version {
		return fmt.Errorf("instance is already running version %s", version)
	}

	// Update the version
	oldVersion := e.milvusVersion
	e.milvusVersion = version

	// Regenerate docker-compose.yaml with new version
	composeContent, err := e.generateComposeFile()
	if err != nil {
		e.milvusVersion = oldVersion // Rollback on error
		return fmt.Errorf("failed to generate compose file: %w", err)
	}

	composePath := e.composePath()
	if err := os.WriteFile(composePath, []byte(composeContent), 0644); err != nil {
		e.milvusVersion = oldVersion // Rollback on error
		return fmt.Errorf("failed to write compose file: %w", err)
	}

	// Pull new image and recreate containers
	if err := e.run(ctx, "pull"); err != nil {
		return fmt.Errorf("failed to pull new image: %w", err)
	}

	// Recreate containers with new image (rolling update for standalone is just a restart)
	if err := e.run(ctx, "up", "-d", "--remove-orphans"); err != nil {
		return fmt.Errorf("failed to recreate containers: %w", err)
	}

	return nil
}

// GetVersion returns the current Milvus version for local deployment
func (e *LocalExecutor) GetVersion(ctx context.Context) (string, error) {
	return e.milvusVersion, nil
}

// userConfigPath returns the path to the user.yaml config file
func (e *LocalExecutor) userConfigPath() string {
	return filepath.Join(e.workDir, "user.yaml")
}

// GetConfig returns the current Milvus configuration from user.yaml
func (e *LocalExecutor) GetConfig(ctx context.Context) (map[string]interface{}, error) {
	configPath := e.userConfigPath()

	data, err := os.ReadFile(configPath)
	if err != nil {
		if os.IsNotExist(err) {
			// No config file yet, return empty config
			return make(map[string]interface{}), nil
		}
		return nil, fmt.Errorf("failed to read config file: %w", err)
	}

	var config map[string]interface{}
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("failed to parse config file: %w", err)
	}

	return config, nil
}

// SetConfig updates the Milvus configuration in user.yaml and restarts the container
func (e *LocalExecutor) SetConfig(ctx context.Context, config map[string]interface{}) error {
	// Load existing config
	existingConfig, err := e.GetConfig(ctx)
	if err != nil {
		return err
	}

	// Merge new config into existing
	mergeConfig(existingConfig, config)

	// Write config to user.yaml
	data, err := yaml.Marshal(existingConfig)
	if err != nil {
		return fmt.Errorf("failed to marshal config: %w", err)
	}

	// Add header comment
	content := "# Milvus Configuration - Generated by miup\n# Modify this file to change Milvus settings\n\n" + string(data)

	if err := os.WriteFile(e.userConfigPath(), []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	// Check if container is running
	running, err := e.IsRunning(ctx)
	if err != nil {
		return err
	}

	// If running, restart to apply config
	if running {
		// Regenerate compose file to ensure user.yaml is mounted
		if err := e.ensureConfigMount(); err != nil {
			return err
		}

		// Restart the standalone container to apply new config
		if err := e.run(ctx, "restart", "standalone"); err != nil {
			return fmt.Errorf("failed to restart container: %w", err)
		}
	}

	return nil
}

// ensureConfigMount ensures that user.yaml is mounted in docker-compose
func (e *LocalExecutor) ensureConfigMount() error {
	// Re-generate compose file to include user.yaml mount
	composeContent, err := e.generateComposeFile()
	if err != nil {
		return fmt.Errorf("failed to generate compose file: %w", err)
	}

	// Check if user.yaml mount already exists, if not add it
	if !strings.Contains(composeContent, "user.yaml") {
		// Add user.yaml mount to standalone service
		composeContent = strings.Replace(composeContent,
			"- milvus_data:/var/lib/milvus",
			"- milvus_data:/var/lib/milvus\n      - ./user.yaml:/milvus/configs/user.yaml:ro",
			1)
	}

	return os.WriteFile(e.composePath(), []byte(composeContent), 0644)
}
